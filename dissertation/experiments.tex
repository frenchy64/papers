\chapter{Experiments}

In this chapter we look at several example of using Typed Clojure and
how well the current prototype handles them. 
We intentially chose examples that could be challenging to type check
or were particularly useful to the everyday Clojure programmer.

\section{Java Interoperability}

As Typed Clojure is intended to be useful for practical purposes, it was important
to port existing code that utilized Java interoperability.
My porting effort attempted to follow how a real programmer might port code to Typed Clojure
and I describe my approach for each situation.

I ported a function from clojure.contrib.reflect\footnote{https://github.com/cemerick/pomegranate}, 
a Clojure library relying heavily on Java interoperability.
I chose \lstinline|call-method| for several reasons: it chains several Java calls together,
it uses primitive arrays, it exposes a wart of Clojure with \emph{Named} things,
and \lstinline|null| is a valid value in one place.

Before showing the implementation, there is a brief explanation of the relevant syntax.
Java methods are called using the \emph{dot} operator. If \lstinline|o| is an object \lstinline|(. o m a*)|
calls its method named \lstinline|m| passing \lstinline|a*| arguments. The method can be named first
using the equivalent sugar \lstinline|(.m o a*)|. Also, \lstinline|doto| is convenient 
notation for muliple method calls on the same object, presumably for side effects, and returns the original
object. For example, \lstinline|(doto o (.m1 a*) (m2 a*))| calls methods \lstinline|m1| and \lstinline|m2|
on \lstinline|o| and returns \lstinline|o|.

\begin{lstlisting}[caption=call-method, label=lst:callmethod]
;; call-method pulled from clojure.contrib.reflect, (c) 2010 Stuart Halloway & Contributors
(defn call-method
  "Calls a private or protected method.

  params is a vector of classes which correspond to the arguments to
  the method e

  obj is nil for static methods, the instance object otherwise.

  The method-name is given a symbol or a keyword (something Named)."
  [^Class klass method-name params obj & args]
  (let [method (doto (.getDeclaredMethod klass 
                                         (name method-name)
                                         (into-array Class params))
                 (.setAccessible true))]
    (.invoke method obj (into-array Object args))))
\end{lstlisting}

The original function is modified slightly for readability and is presented in listing \ref{lst:callmethod}.

\begin{lstlisting}[caption=call-method Type Annotation, label=lst:callmethodtype]
(ann call-method 
     [Class Named (IPersistentVector Class) (U nil Object) (U nil Object) * -> (U nil Object)])
\end{lstlisting}

Thankfully this function has up-to-date documentation, and from it we can derive an expected type
(listing \ref{lst:callmethodtype}).

Before running the type checker we must convert our array constructors into ones that Typed Clojure
can understand. Array types in Typed Clojure are represented by \lstinline|(Array c t)|, where
the Java class \lstinline|c| is the Java component type,
and the Typed Clojure type \lstinline|t| is the Typed Clojure component type. 
We can pass this array to Java methods accepting
type \lstinline|c[]|, and we can read and write type \lstinline|t| to the array from Typed Clojure.

\begin{itemize}
\item \lstinline|(into-array Class params)| becomes \lstinline|(into-array> Class Class params)|
      which is of type \lstinline|(Array Class Class)|.
\item \lstinline|(into-array Object args)| becomes \lstinline|(into-array> Object (U nil Object) args)|
      which is of type \lstinline|(Array Object (U nil Object))|.
\end{itemize}

The second place in the \lstinline|Array| type constructor allows fine grained control over what is allowed
in the array. The first point above must be type \lstinline|(Array Class Class)| because the 
\lstinline|getDeclaredMethod| method on \lstinline|java.lang.Class| instances requires an array of non-null
\lstinline|Class| objects. On the other hand, the \lstinline|invoke| method takes an array that allows
\emph{null} members, so its type is \lstinline|(Array Object (U nil Object))|.

Now we run the type checker, which produces a type error.

\begin{lstlisting}
#<Exception java.lang.Exception: 29: Cannot call instance method java.lang.reflect.AccessibleObject/setAccessible on type (U nil java.lang.reflect.Method)>
\end{lstlisting}

Because Typed Clojure assumes all methods return nilable Objects, the call to \lstinline|getDeclaredMethod|
has return type \lstinline|(U nil java.lang.reflect.Method)|. It is not type safe to call \lstinline|setAccessible|
on this type, so we get a type error.

In this case, Typed Clojure is too conservative: according to its documentation \lstinline|getDeclaredMethod|
never returns \emph{null}. We add this rule with \lstinline|non-nil-return|.

\begin{lstlisting}
(non-nil-return java.lang.Class/getDeclaredMethod :all)
\end{lstlisting}

Running the type checker produces a different type error.

\begin{lstlisting}
#<Exception java.lang.Exception: Type Error, REPL:32 - (U java.lang.Object nil) is not a subtype of: java.lang.Object>
\end{lstlisting}

This concerns passing \lstinline|obj| as the first argument to the \lstinline|invoke| method.
Typed Clojure conservatively defaults method parameter types as non-nullable. 
Therefore the first parameter of \lstinline|invoke| is \lstinline|Object| by default; \lstinline|obj|
is \lstinline|(U java.lang.Object nil)|. Again, this is too conservative as the first argument can
be \emph{null} for static methods, and we use \lstinline|nilable-param| to specify the first argument
of \lstinline|invoke| may be nil, for the arity of two parameters.

\begin{lstlisting}
(nilable-param java.lang.reflect.Method/invoke {2 #{0}})
\end{lstlisting}

Here is the final successfully type checked code.
\begin{verbatim}Is this a reasonable result?\end{verbatim}

\begin{lstlisting}
(non-nil-return java.lang.Class/getDeclaredMethod :all)
(nilable-param java.lang.reflect.Method/invoke {2 #{0}})

(ann call-method [Class Named (IPersistentVector Class) (U nil Object) (U nil Object) * -> (U nil Object)])

;; call-method pulled from clojure.contrib.reflect, (c) 2010 Stuart Halloway & Contributors
(defn call-method
  "Calls a private or protected method.

  params is a vector of classes which correspond to the arguments to
  the method e

  obj is nil for static methods, the instance object otherwise.

  The method-name is given a symbol or a keyword (something Named)."
  [^Class klass method-name params obj & args]
  (let [method (doto (.getDeclaredMethod klass 
                                         (name method-name)
                                         (into-array> Class Class params))
                 (.setAccessible true))]
    (.invoke method obj (into-array> Object (U nil Object) args))))
\end{lstlisting}

\section{Red-Black Tree}

\section{Monads}
\label{sec:monads}

Monads are an interesting control structure used in functional programming languages,
as described by Wadler\cite{Wad95}.
They are most recognisable from its inclusion in the statically-typed language Haskell\cite{Mar10},
where monads are relied on for many features including global state, file output, and exceptions.

I chose to port the Clojure Contrib library \emph{algo.monads}\cite{Hic12} to Typed Clojure. The library
provides several kinds of monads, monad transformers, and monadic functions.
Macros are used to provide pleasant syntax for consumers of the library.

\subsection{Monad Definitions}
\label{sec:monaddef}

This library represents a monad as a hash-map with four keys: \lstinline|:m-bind|, \lstinline|:m-result|,
\lstinline|:m-zero|, and \lstinline|:m-plus|. A valid monad must provide the first two, and the latter
two may optionally be mapped to the keyword \lstinline|::undefined|\footnote{Keywords prefixed with \lstinline|::|
are qualified in the current namespace.}.

\begin{lstlisting}[caption=Untyped definition for the identity monad, label=lst:identitymdef]
(defmonad identity-m
   "Monad describing plain computations. This monad does in fact nothing
    at all. It is useful for testing, for combination with monad
    transformers, and for code that is parameterized with a monad."
  [m-result identity
   m-bind   (fn m-result-id [mv f]
              (f mv))
  ])
\end{lstlisting}

A monad is defined using the macro \lstinline|defmonad|. The macro expands to code that binds a var to a hash-map
with the aforementioned keys.

\begin{lstlisting}[caption=Type for identity monad, label=lst:identitymtype]
(def-alias Undefined '::undefined)
(ann identity-m
     '{:m-bind (All [x y]
                 [x [x -> y] -> y])
       :m-result (All [x]
                   [x -> x])
       :m-zero Undefined
       :m-plus Undefined})
\end{lstlisting}

A direct typing of the identity monad would look like listing \ref{lst:identitymtype}.
This signature assigns the expected type for the var \lstinline|identity-m| 
to be a heterogeneous map type with the minimum entries for monads: \lstinline|:m-bind|
and \lstinline|:m-result|. The syntax for heterogeneous map types requires a \lstinline|'| prefix,
and any number of key-value pairs are given between curly braces. Heterogeneous map keys must be keywords,
so the syntax is made more convenient by omitting the usually required \lstinline|'| prefix
for keyword types.

Monad types in languages with advanced type systems are often abstracted using type constructors.
This allows reasoning about monadic code while keeping the particular monad abstract, which is a desirable result,
so Typed Clojure was extended to support user definable type constructors.

\begin{lstlisting}[caption=An abstract definition of a monad., label=lst:monadalias]
(def-alias Monad 
  (TFn [[m :kind (TFn [[x :variance :covariant]] Any)]]
    '{:m-bind (All [x y]
                [(m x) [x -> (m y)] -> (m y)])
      :m-result (All [x]
                  [x -> (m x)])
      :m-zero Undefined
      :m-plus Undefined}))
\end{lstlisting}

Listing \ref{lst:monadalias} captures the abstract definition of a monad.
A \lstinline|Monad| is a type constructor parameterised by \lstinline|m|, which is
a type constructor taking a single argument \lstinline|x| (a type) and returning a type 
(written \lstinline|Any|)\footnote{Haskell-like syntax is helpful here, the kind \lstinline|(TFn [[x :variance :covariant]] Any)|
is approximately \lstinline|* -> *|. A more streamlined syntax is planned for future work.}.
The body of the type constructor uses \lstinline|m| abstractly. Typed Clojure
ensures the correct number of arguments are passed and recognises the declared variances
for each parameter, In this case the first argument of \lstinline|m| is declared
a covariant position. When instantiated, \lstinline|m| must also be a type operator
of one covariant argument returning a type.

\begin{lstlisting}[caption=Identity monad using user defined type constructors, label=lst:identityctors]
(ann identity-m (Monad (TFn [[x :variance :covariant]] x)))
\end{lstlisting}

We can now express the type of the identity monad more abstractly (listing \ref{lst:identityctors}).
The purpose of the monad seems more apparent just from reading its type.
In this case, the fact that identity monad has no effect is reflected
by its type constructor returning exactly its argument.

\begin{lstlisting}[caption=Type checked identity monad definition, label=lst:identitydeftyped]
(defmonad identity-m
   "Monad describing plain computations. This monad does in fact nothing
    at all. It is useful for testing, for combination with monad
    transformers, and for code that is parameterized with a monad."
  [m-result identity
   m-bind   (ann-form
              (fn m-result-id [mv f]
                (f mv))
              (All [x y]
                [x [x -> y] -> y]))
  ])
\end{lstlisting}

The final type checked definition for the identity monad is given in listing \ref{lst:identitydeftyped}.
In this case, just the monadic bind required annotation.

\begin{lstlisting}[caption=Several monad types, label=lst:severalmonads]
; Maybe monad
(ann maybe-m (MonadPlusZero
               (TFn [[x :variance :covariant]] 
                 (U nil x))))

; Sequence monad (called "list monad" in Haskell)
(ann sequence-m (MonadPlusZero 
                  (TFn [[x :variance :covariant]]
                    (Seqable x))))

; State monad
(def-alias State
  (TFn [[r :variance :covariant]
        [s :variance :invariant]]
    [s -> '[r s]]))
(ann state-m (All [s]
               (Monad (TFn [[x :variance :covariant]]
                        (State x s)))))
\end{lstlisting}

Listing \ref{lst:severalmonads} shows several monad types. The alias \lstinline|MonadPlusZero|
is identical to \lstinline|Monad|, except both \lstinline|:m-zero| and \lstinline|:m-plus| are defined.
The definitions were type checked by adding type annotations in appropriate places, in a similar fashion
to the identity monad. A significant obstacle was discovered in while type checking monad definitions,
relating to filtering sequences with negative type information, discussed in section \ref{sec:filterneg}.

\subsection{Monad Transformer Definitions}

The initial motivation for adding user defined type constructors to Typed Clojure
(as discussed in section \ref{sec:monaddef}) was to type check
monad transformer definitions.
Monad transformers are always parameterised by a monad type constructor, and should work for all
monad type constructors. Keeping the monad type constructor abstract allows us to determine
whether a monad transformer works \emph{for any} monads.


\section{Conduit}
