% TODO
% What does this Lit review cover?
% Why things are included/not included?
% Background
% Heterogeneous Maps/record types
% Soft typing
% See Sam's dissertation
% Lisp type system background (197x)
% Why was it so hard?
% - bidirectional checking vs. global inference

\chapter{Literature Review}

In this chapter we fit the design of Typed Clojure with literature from related fields.
Forward-references are given to link the discussed literature with this project
where there is some relevance or influence.

%Typed Clojure is related to several existing systems for both typed and untyped languages.

\section{Static Type Systems}

% Haskell
% OCaml
% Forsythe
% Java C#
% Scala

\section{Static Types for Untyped Languages}

There is a history of designing static type systems for untyped languages. 

\subsection{Soft Typing}

Soft typing\cite{CF91}
is an approach for ensuring type safety in untyped languages.
A soft type system infers types for programs, distinguishing between degrees
of potential type safety.
A soft type checker uses this information to 
preserve type safety by inserting appropriate checks 
and informs the programmer of potential inconsistencies.
For example, if the soft type system detects a portion of code is sometimes not type safe,
the soft type checker inserts a check that throws a runtime error upon unsafe usages.
Thus, soft type systems differ from traditional type systems in that type inference 
never fails and an inconsistency always results in a runtime check.

Wright and Cartwright\cite{WC97} developed Soft Scheme, a practical
soft type system for Scheme. 
It extended earlier work by Cartwright and Fagan\cite{CF91}
and Fagan \cite{Fag91}, adding support for practical features such as
first-class continuations and variable-arity functions.
Soft Scheme does not require any extra type annotations.

Type systems for Scheme have since moved away from soft typing
to to other approaches like gradual typing.
Alas, the best reference for commentary on this transition 
appears to be slides from a talk by Felleisen\cite{Fell09},
a leader in this area of research for over 20 years.
Felleisen says that while Soft Scheme discovered type problems, 
it suffers from incomprehensible
errors that required PhD-level expertise to decipher. 

\begin{verbatim}
  Bidirectionality
\end{verbatim}

\subsection{Gradual Typing}

Gradual typing combines static and runtime type checking so programmers
can the most appropriate one for the situation.

Typed Racket was developed as a path for module-by-module
porting of existing untyped Racket modules to a typed sister language\cite{Tob10}.
Once a module is ported and type checked, it is protected from untyped modules
by inserting runtime checks.

\begin{verbatim}
  Different levels of Gradual Typing discussed by Siek..
\end{verbatim}

\section{Interlanguage Interoperability}

This section compares several existing languages that feature interlanguage interoperability.

Clojure is a dynamic functional language hosted on the Java Virtual Machine. It provides 
interoperability with Java libraries. As Clojure is a dynamically typed language, it does
not give strong type type guarantees at compile time whether interactions with Java
are type safe.

Scala is a statically typed language on the Java Virtual Machine offering integrated interoperability with Java, a typed language.
Scala objects and classes can ``inherit from Java classes and implement Java interfaces''\cite{OCD+}
with the usual static type guarantees normal Scala code enjoys.
Scala offers an Option type to safely eliminate null pointers.
Java Generics are also fully supported by Scala, accounting for Scala support existential types

Typed Racket includes safe interoperability between any combination of typed and untyped 
Racket modules\cite{Tob10}\cite{TF08}. 
Interactions with untyped modules are protected by adding runtime checks based on expected types.
Typed Racket implements a sophisticated blame calculus. It ensures 
error messages correctly \emph{blame} the source of type errors,
which can be difficult to determine in the presence of higher-order functions. 
\begin{verbatim}references, Walder etc.\end{verbatim}

\section{Record Types}

This section summarises research in typing OCaml-style records
which relate to Clojure records and heterogeneous hash maps.

\section{Intersection, Union, and Singleton Types}
\label{sec:intersection_types}

% Hiyashi Singleton types
% Intersection types - CDV81
% Unions in soft typing CF91
% - Static Type Inference in a Dynamically Typed Lanugage
%  - cited by CF91, which has unions

Intersection and union types are interesting type constructs relevant to capturing the complicated
types common in dynamic languages.
An expression of type \lstinline|(I a b)|, an intersection type including types \lstinline|a|
and \lstinline|b| in Typed Clojure, can be used safely in both positions expecting type \lstinline|a|,
and positions expecting type \lstinline|b|.
An expression of type \lstinline|(U a b)|, a union type including types \lstinline|a| in Typed Clojure,
and expressions of this type can be used safely in positions 
that expect a type that is \emph{either} type \lstinline|a|
or \lstinline|b|.
For example, \lstinline|(U Number Boolean)| cannot be used in positions expecting \lstinline|Number|.
% TODO Intersection example

Several interesting projects have used intersection or union types.

Forsythe, a modern ALGOL dialect by Reynolds\cite{Rey96} was the first wide-spread 
programming language to use intersection types.
Uses of intersections in Forsythe include representing extensible record types
and function overloading.

Refinement types add a level of types refining an existing type system
in order to type check more detailed properties and invariants than standard static type systems
(described by Freeman and Pfenning\cite{FP91}).
Intersection types are critical here to allow more than one property or invariant
to be expressed for a function.
SML CIDRE is a refinement type checker for Standard ML by Davies \cite{Dav05}.
\begin{verbatim}
Refinement types are similar to this project ... how?
\end{verbatim}

St-Amour, Tobin-Hochstadt, Flatt, and Felleisen
describe the \emph{ordered intersection types} used in Typed Racket\cite{St12}
that provide a kind of function overloading.
Typed Clojure takes a similar approach
\begin{verbatim}
described in chapter
\end{verbatim}
Typed Racket also uses disjoint union types, 

\section{Java Interoperability}

Scala and Clojure are both languages with a focus on host interoperability, specifically
to the Java Virtual Machine. Their differing treatment of the Java Virtual Machine's \lstinline|null| is
relevant, particularly considering the potential of using occurrence typing \cite{TF10}
to prevent erroneous usage of \lstinline|null|.
\begin{verbatim}
eg.
\end{verbatim}

\section{Function Types}

There are several different approaches to representing functions in programming languages.

In typed languages like Haskell, functions are as simple as possible, taking a single argument.
A function with multiple arguments is represented by chaining several single-argument function
together, or by using lists, or using tuples. This style is characterised by direct syntactic function currying, where applying
a function to less than its maximum number of arguments results in another function
that takes the remaining arguments.

In untyped languages like Scheme, functions can take any number of arguments. It is an
error to supply less than the minimum number of arguments to a function.
This style features sophisticated support for functions with variable-arity. For example,
functions can dispatch on the number of arguments provided, and supports a \emph{rest} parameter
as its last parameter which can accept any number of arguments.

In this regard, Clojure takes an approach identical to Scheme, and supports all the features
mentioned in the previous paragraph, and none characterised by Haskell-style functions.
For this reason, we ignore the tradeoffs associated between the two approaches 
and move directly to literature applicable to typing Scheme-style functions.

\subsection{Variable-Arity Polymorphism}

Strickland et al. invented a type system supporting variable-arity polymorphism\cite{STF09}
a version of which is included in the current implementation of Typed Racket.
Their main innovation centres around \emph{dotted type variables}, which represent a heterogeneous sequence
of types. Dotted type variables allow \emph{non-uniform} variable-arity function types,
which are used to check definitions and usages of functions with non-trivial rest parameters

For example in Clojure, the function \lstinline|map| takes a function and one or more sequences,
and returns the result of applying the function argument to each element of the sequences pair-wise.

\begin{lstlisting}[caption=An application of the non-uniform variable-arity function \lstinline|map|, label=lst:map]
(map + [1 2] [2.1 3.2]) 
;=> (3.1 5.2)
\end{lstlisting}\footnote{Line comments in Clojure begin with \lstinline|;| and comments to the end of the line. We use \lstinline|;=>| to mean \emph{evaluates to}.}

To statically check calls to \lstinline|map|, we must enforce the provided function argument can accept as many
arguments as there are sequence arguments to \lstinline|map|, and the parameter types of the provided function can accept
the pair-wise application of the elements in each sequence. This is a complex relationship between the variable parameters and
the rest of the function.
Listing \ref{lst:map} requires the first argument to \lstinline|map| to be a function of 2 parameters because
there are two sequence parameters. \lstinline|+| takes any number of \lstinline|Number| parameters, 
and applying pair-wise arguments of \lstinline|(Vector Long)| and \lstinline|(Vector Double)| 
results in types \lstinline|Long| and \lstinline|Double| being applied to \lstinline|+|. These are subtypes
of \lstinline|Number|, so the expression is well typed.

\section{Type Inference}

\subsection{Local Type Inference}

Typed Racket uses Local Type Inference \cite{PT00}
as an inference and checking tool. Pierce and Turner
\cite{PT00} divide Local Type Inference into
two complementary algorithms. \emph{Local type argument synthesis}
synthesises type arguments to polymorphic applications, and \emph{bidirectional
propagation} propagates type information both down and up the source tree,
known as \emph{checking} and \emph{synthesis} mode respectively.

\begin{lstlisting}[caption=Bidirectional checking algorithm with Typed Clojure pseudocode, label=lst:bidir]
(map (fn [[a :- Long] [b :- Float]]
       (+ a b))
     [1 2]
     [2.1 3.2])
;=> (3.1 5.2)
\end{lstlisting}

The pseudocode in listing \ref{lst:bidir} show both algorithms in action. Local type argument synthesis is able
to infer the type arguments to \lstinline|map| by observing the argument types of the first
argument to \lstinline|map| and the types of subsequent sequence arguments. Bidirectional checking
then \emph{synthesises} the resulting type of the expression by \emph{checking} each element
of \lstinline|[1 2]| is a subtype of \lstinline|a|, and each element of \lstinline|[2.1 3.2]| is a subtype of
\lstinline|b|. The result of the anonymous function argument is \emph{synthesised} from the type of
\lstinline|(+ a b)| as \lstinline|Float|. We now have sufficient information to 
synthesise the type of listing \ref{lst:bidir} to be \lstinline|(List Float)|.

Pierce and Turner split \emph{local type argument synthesis} into two further
algorithms: bounded, and unbounded quantification \cite{PT00}. 
Typed Racket 
supports unbounded polymorphism \cite{Tob10}, implementing the latter algorithm by Piece et al.
Scala supports bounded quantification with F-bounded polymorphism \cite{CCHOM89},
basing its type argument synthesis on the bounded quantification algorithm.

Pierce and Turner explicitly forbid \cite{PT00}
attempting to synthesise type variables with interdependent bounds, including
F-bounds, having failed to devise an algorithm to infer these cases.
Scala's type argument synthesis implementation deviates from Pierce and Turner and supports these features.
I am not aware of papers specifically describing Scala's modifications, but they are at least inspired by
Scala's spiritual ancestors Generic Java \cite{BOSW98} and Pizza \cite{OW97}.

Hosoya and Pierce \cite{HP99} reiterate two common problems with Local Type Inference:
``hard-to-synthesise arguments'' and ``no best type argument''. The first problem occurs because
both local type argument synthesis and bidirectional propagation cannot perform synthesis
simultaneously. 

\begin{lstlisting}[caption=Hard-to-synthesise expression, label=lst:hts]
(map (fn [a b] 
       (+ a b)) 
     [1 2] 
     [2.1 3.2])
\end{lstlisting}

Listing \ref{lst:hts} shows an example of this limitation,
here caused by both not providing type arguments to \lstinline|map| and not providing the parameter types of \lstinline|(fn [a b] (+ a b))|.
 Cases where both algorithms can simultaneously recover new type information are usually ``hard-to-synthesise''.
``No best type argument'' describes the situation where the results of local
type argument synthesis yield more than one type, and no type is better than the other. Sometimes we cannot recover and synthesis
fails.

\subsection{Colored Local Type Inference}

Scala's type checking uses Colored Local Type Inference \cite{OZZ01},
a variant of Local Type Inference \cite{PT00} specifically designed to
improve inference with certain kinds of Scala pattern matching expressions. It allows
\emph{partial} type information to propagate down the syntax tree, instead of only full type information
as required by Local Type Inference.

\emph{Colored} types contain extra contextual information, including the propagation direction
and missing parts of the type. They are generally useful
for describing ``information flow in polymorphic type systems with propagation-based type inference''
\cite{OZZ01}. If the scope of my research permits it, I plan to investigate
using colored types to solve the polymorphic higher-order-function limitation of Local Type Inference
(see listing \ref{lst:hts}).

\section{Bounded and Unbounded Polymorphism}

Local type inference by Pierce and Turner\cite{PT00}
describe two implementations of type variables, for bounded
and unbounded type variables. The bounded implementation is presented
as an optional extension  to the unbounded implementation, which preserves all
properties described in the Local Type Inference algorithm.

An unbounded type variable does not have subtype constraints.
Bounded type variables can have subtype constraints, and 
subsume unbounded type variables \cite{PT00}, 
as a unbounded variable can be represented as a variable bounded
by the Top type.

Still, unbounded type variables have an advantage: their implementations are
are simpler in the presence of a \emph{Bottom} type. 
The constraint resolution algorithm for bounded variables
is more subtle, due to ``some surprising interactions between bounded quantifiers
and the \emph{Bot} type'' \cite{PT00}, described fully
by Pierce \cite{Pie97}.

Typed Racket \cite{TF08}
supports unbounded polymorphism, while Scala \cite{OCD+}
supports an extended form of bounded polymorphism called
F-bounded polymorphism \cite{CCHOM89}, which allows the
bound variable to occur in its own bound.
F-bounded polymorphism is useful in the context of object-oriented abstractions,
as demonstrated by Odersky \cite{OCD+}.
This is one possible explanation why Typed Racket, which is not built on abstractions like Scala,
does not support bounded quantification. Unfortunately, no Typed Racket paper mentions 
bounded quantification, so the rationale is not clear.

Clojure, like Scala, is built on object-oriented abstractions. Clojure protocols
and Java interfaces (interfaces are supported by Clojure) are good candidates
for bounds in bounded or F-bounded polymorphism.

\section{Typed Racket}

Typed Racket is a statically typed sister language of Racket. It
attempts to preserve existing Racket idioms and aims type check
existing Racket code by simply adding top level type annotations \cite{Tob10}.

Typed Racket fully expands all macro calls before type checking \cite{Tob10} to
avoid the complex semantics of type checking macro definitions, an ongoing research area summarised
 by Herman \cite{Her10}.
The design of my Clojure type system will follow a similar strategy; only the fully macro-expanded form
will be type checked. Type checking macro definitions are outside the scope of this project, and would
be exceptionally hard.

Along with a full static type system, Typed Racket 
also uses runtime contracts to enforce type invariants at runtime \cite{TF08}.
Utilising runtime contracts to aid type checking is outside the scope of this project, but would be 
considered desirable and accessible future work.

Two other Typed Racket features that will be explored are recursive types and refinement types  
\cite{Tob10}. Recursive types allow a type definition to refer to itself, enabling structurally
recursive types like binary trees. Refinement types let the programmer define
new types that are subsets of existing types, such as the type for even integers, a subset of all integers.
Both these features would fit well in a future implementation of this project.

\section{Occurrence Typing}
\label{sec:OccurrenceTyping}

Dynamically typed languages use an ad-hoc combination of type predicates,
selectors, and conditionals to steer execution flow and reason about runtime types of variables.
Typed Racket uses occurrence typing to capture these ad-hoc type refinements.
For example, listing \ref{lst:occ1} shows occurrence typing following the implications 
of the type predicate \emph{number?} and the selector \emph{first}, and utilises those implications to refine
the type of \lstinline|x|. If the test at line 3 succeeds, occurrence typing refines the
type of \lstinline|(first x)| to be \lstinline|Number|, which allows \lstinline|(+ 1 (first x))|
to be well typed. Similarly at line 4, we can be sure that \lstinline|(first x)| is
a \lstinline|String|, since we have ruled out the case of being a \lstinline|Number|.

\begin{lstlisting}[caption=A well typed form utilising occurrence typing with Clojure syntax, label=lst:occ1]
(let [x (list (number-or-string))]
  (cond 
    (number? (first x)) (+ 1 (first x))
    :else               (str (first x))))
\end{lstlisting}

Occurrence typing \cite{TF08}
\cite{TF10} extends the type 
system with a \emph{proposition environment} that represents 
the type refinements inferred down a particular path.
The 2010 paper \cite{TF10}
reformulated occurrence typing, improving the original 2008 paper
\cite{TF08}
after revealing that ``three years of practical experience has revealed
serious shortcoming of our type system.''\cite{TF10}
The new implementation utilizes a simple proof system to solve
propositional logic statements, in terms of type predicates and selectors.

For occurrence typing to infer propositions from type predicate usages, it requires 
two extra annotations: a ``then'' proposition
when the result is a true value, and an ``else'' proposition for a false value.
For example, \lstinline|number?| has a ``then'' proposition that says its argument
is of type \lstinline|Number|, and an ``else'' proposition that says its argument is not of type \lstinline|Number|.

An exciting application of occurrence typing as yet unexplored is facilitating null-safe interop with Java.
By declaring \lstinline|nil| (Clojure's value of Java's \lstinline|null|) to \emph{not} be a subtype of reference types,
we can begin to statically disallow potential inconsistent usages of \lstinline|nil| as part of the type system.

\begin{lstlisting}[caption=Observing nil-checks using occurrence typing, label=lst:nil]
(let [a (ObjectFactory/getObject)]
  (when a
    (expects-non-nil a)))
\end{lstlisting}

Listing \ref{lst:nil} infers from the Java signature \lstinline|Object getObject()| that
that \lstinline|a| is of type \lstinline|(U nil Object)|. This is equivalent to Java's
\lstinline|Object| static type, as \lstinline|null| is a subtype of all reference types. By surrounding
the call \lstinline|(expects-non-nil a)| with \lstinline|(when a ...)|, we guarantee that
\lstinline|a| is non-nil when passed to \lstinline|expects-non-nil|. Occurrence typing infers
this by observing \lstinline|nil| is a false value in Clojure, therefore \lstinline|a| cannot
be \lstinline|nil| the body of the \lstinline|when|, refining \lstinline|a|'s type to \lstinline|Object|
from \lstinline|(Union nil Object)|.

Occurrence typing is a relatively simple, time worn technique used successfully 
in Typed Racket. Clojure is similar enough to Racket for occurrence typing to work
without issues, and has good potential to enable null-safe Java interop.

\section{Statically Typed Multimethods}

Clojure provides multimethods as a core language feature. This section discusses systems that statically
verify type safety for multimethods.

Millstein and Chambers\cite{MS02}
describe Dubious, a simple statically typed core language including multimethods that
dispatch on the type of its arguments. They tackle a key challenge for statically typing
multimethods: ``it is possible for two modules containing arbitrary multimethods to typecheck
successfully in isolation but generate type errors when linked together.''\cite{MS02}

\section{Higher Kinded Programming}

\begin{verbatim}
Many advanced type systems provide support for ..
Forward reference to algo.monad experiment.
\end{verbatim}

\section{Conclusion}

Many related components must come together in the design of a
static type system. Typed Racket achieves a satisfying balance of 
occurrence typing, local type inference and variable-arity polymorphism.
Similarly, Scala features F-bounded polymorphism, a class hierarchy
that is compatible with Java, and colored local type inference.
