\chapter{Implementation}

This chapter discusses the implementation of the Typed Clojure prototype type 
system\footnote{We refer to this implementation as \emph{Typed Clojure} for the remainder of this chapter.}.
concentrating on significant challenges that were identified and overcome.
Many aspects of Typed Clojure's design follows the implementation of Typed Racket

\section{Type Checking Procedure}

Typed Clojure and Typed Racket differ significantly in how they interact with
the Clojure and Racket respectively to perform type checking.
Typed Racket is implemented as a language on the
Racket platform, which provides highly sophisticated and extensible macro facilities.
This allows Typed Racket to be entirely implemented with macros.
Instead, Typed Clojure is implemented as a library that utilises abstract syntax trees (AST)
generated by analyze, a library developed for this project.

There are several stages to type checking in Typed Clojure.
Type checking is typically initiated at the read-eval-print-loop prompt (REPL),
for example \lstinline|(check-ns 'my.ns)| checks the namespace \lstinline|my.ns|.
Before type checking begins, all global type definitions in the namespace
are added to the global type environment by compiling the namespace.
These type definitions include

\begin{itemize}
  \item type alias definitions
  \item var, protocol, datatype, and Java Class annotations
  \item Java method annotations, such as \lstinline|nilable-param| and \lstinline|non-nil-return|
\end{itemize}

An AST is then generated from the code contained in the target namespace.
This AST is then recursively descended and is type checked using local type inference.
Currently only one error is reported at a time, and type checking stops if a type error
is found.

\section{Occurrence typing}

Typed Clojure's implementation of occurrence typing is ported and extended from Typed Racket.
Occurrence typing plays several roles in Typed Clojure.
First, occurrence typing is used to update the type environment at every conditional branch.
Second, it is used to calculate whether branches are reachable: a branch is not reachable
if updating the type environment results in a variable of the bottom type.
Third, paths are used extensively in Typed Clojure. Typed Racket uses \emph{car} and \emph{cdr} paths
to track which component of a cons cell to update. Typed Clojure adds paths for traversing heterogeneous maps,
inferring length information, and \lstinline|first| and \lstinline|rest| paths for sequences.

\section{Variable-arity Polymorphism}

Variable-arity polymorphism in Typed Clojure is directly ported from Typed Racket.
This was the most complicated part of the prototype. At the center of the implementation
is manipulating dotted type variables, which can represent a sequence of types.

\section{Portability to other Clojure Dialects}

Typed Clojure was built for the Clojure programming language, whose compiler
and data structures are implementated in Java. Clojurescript is the first major Clojure dialect
to be written in Clojure, and it is likely future dialects of Clojure will follow this example. 
Where Clojure uses Java Classes and Interfaces, 
Clojurescript's compiler and data structures are written in terms of Clojure's
two core abstractions: protocols and datatypes.
It would desirable to port Typed Clojure to similar  Clojure dialects while keeping
the core of the implementation constant.

A significant portion of Typed Clojure is theoretically platform independent but there are
challenges to targeting new dialects, including incompatible host interoperability and
non-standardised abstract syntax trees.
The first issue is predictable due to a core philosophy of Clojure dialects: 
host interoperability is non-portable\footnote{See the complete Clojure rationale: http://clojure.org/rationale}.
Each dialect of Clojure has a unique host interopability story and Typed Clojure should cater for them
separately.
The second issue is potentially resolvable. 

\section{Composite Propositions}

\section{Non-hygienic Macro Expansion and Filters}
% need to remove bindings as they fall out of scope
% Need hygiene to ensure correct propagation of filters
%(fn [a]
%  (if (= a 1)
%    (let [a 'foo] ; here this shadows the argument, impossible to recover filters
%      a)          ; in fact any new filters about a will be incorrectly assumed to be the argument
%      false))

