\chapter{Implementation}

This chapter discusses the implementation of the Typed Clojure prototype type 
system (we refer to this implementation as \emph{Typed Clojure} for the remainder of this chapter)
in some detail concentrating on significant challenges that were identified and overcome.
Many aspects of Typed Clojure's design follow the implementation of Typed Racket,
which is reflected in this chapter.

\section{Type Checking Procedure}

Typed Clojure and Typed Racket differ significantly in how type checking
is integrated into their programming environments.
Typed Racket is implemented as a language on the
Racket platform, which provides highly sophisticated and extensible macro facilities.
Interestingly, this allows Typed Racket to be entirely implemented with macros.
Instead, Typed Clojure is implemented as a library that utilises abstract syntax trees (AST)
generated by analyze~\cite{Analyze2012}, a library I developed for this project.
This strategy follows common practice for Clojure projects, which favours providing modular libraries 
over modifying the language.

This section goes into details on the implementation of Typed Clojure.
First, a high-level overview is given on the type checking procedure.
Then the interfaces to particular high-level functions are discussed.

\subsection{General Overview}

There are several stages to type checking in Typed Clojure.
Type checking is typically initiated at the read-eval-print-loop prompt (REPL),
for example \lstinline|(check-ns 'my.ns)| checks the namespace \lstinline|my.ns|.
Before type checking begins, all global type definitions in the namespace
are added to the global type environment by compiling the namespace.
These type definitions include

\begin{itemize}
  \item type alias definitions
  \item global variable, protocol, datatype, and Java Class annotations
  \item Java method annotations, such as \lstinline|nilable-param| and \lstinline|non-nil-return|
\end{itemize}

An AST is then generated from the code contained in the target namespace.
This AST is then recursively descended and is type checked using local type inference.
Currently only one error is reported at a time, and type checking stops if a type error
is found.

\subsection{Bidirectional Checking}

The interface to the bidirectional checking algorithm is \lstinline|typed.core/check|,
which takes an expression, represented as an AST generated from \emph{analyze}, and an optional expected type for
the given expression. If the expected type is present, the bidirectional algorithm \emph{checks}
that the expected type matches the actual type of the expression.
If the expected type is omitted, a type is instead \emph{synthesised} for the expression.
The algorithm is based on Pierce and Turner's  Local Type Inference~\cite{PT00}
and the implementation is similar in form to Typed Racket's~\cite{TF08}, in that
one function with an extra ``expected type'' argument is preferred over two complementary
functions, one for checking and one for synthesis.

The main difference between Typed Clojure's and Typed Racket's bidirectional checking
algorithm is the representation for expressions. Typed Racket relies on pre-existing
Racket features like syntax objects for expression representation. Clojure instead
leans towards abstract syntax tree representation, despite its Lisp heritage.
In terms of the bidirectional checking, the difference is mostly cosmetic.


% go into more detail
% - update env
% - what is an environment? Bindings + propositions
% - LOC
% - link to github
% - how occurrence typing works
%   - update env
%   - how to calculate reachability 

\subsection{Occurrence typing}
\label{sec:occurenceimpl}

Typed Clojure's implementation of occurrence typing is ported and extended from Typed Racket.
Occurrence typing plays several roles in Typed Clojure.
First, occurrence typing is used to update the type environment at every conditional branch.
Second, it is used to calculate whether branches are reachable.
Third, paths are used extensively in Typed Clojure. 
The implementation of these features are discussed in this section.

The basic idea of occurrence typing involves keeping a separate environment of \emph{propositions}
that relate bindings to types. These propositions are then used to update the type environment.
In Typed Clojure there are several types of propositions, referred to as \emph{filters}.
They are based on the theory by Tobin-Hochstadt and Felleisen~\cite{TF10}, and are ported directly
from Typed Racket.


\begin{itemize}
  \item TopFilter and BotFilter represent the trivially true and trivially false propositions respectively.
  \item TypeFilter and NotTypeFilter represent a positive or negative association of a binding name
        to a type. The syntax \lstinline|(is t name)| means a proposition that the binding called
        \lstinline|name| is of type \lstinline|t| (corresponding to TypeFilter).
        The syntax \lstinline|(! t name)| means a proposition that the binding called \lstinline|name|
        is \emph{not} of type \lstinline|t| (corresponding to NotTypeFilter).
  \item AndFilter and OrFilter represent logical conjunction of propositions 
    (written \lstinline[mathescape]|(& $\overrightarrow{p}$)|), and
    logical disjunction of propositions
    (written \lstinline[mathescape]{(| $\overrightarrow{p}$)}) for propositions \lstinline|p|.
\end{itemize}

Propositions can optionally carry \emph{path} information
represented by a sequence of \emph{path elements}, which signify which part
of the binding's type to update. For example, Typed Racket uses \emph{car} and \emph{cdr} path elements
to track which component of a cons type to update.
Paths are particularly useful in Typed Clojure. There are path elements for traversing heterogeneous map types (KeyPE),
inferring length information (CountPE), and \lstinline|first| and \lstinline|rest| paths for sequences.
These additions do not appear to introduce any major new complexities related to paths.

\section{Polymorphic Type Inference}

The polymorphic type inference algorithm is directly ported from Typed Racket with slight extensions
for bounded variables,
and is directly based on Pierce and Turner's Local Type Inference~\cite{PT00}.
A common entry point for inferring type variables for polymorphic function invocations
is \lstinline|typed.core/infer|.

\lstinline|infer| is invoked like \lstinline|(infer X Y S T R expected)|, where

\begin{itemize}
  \item \lstinline|X| is a map from type variable names
        to their bounds (representing the type variables in scope),
  \item \lstinline|Y| is a map from type variable names
        to their bounds (representing the \emph{dotted} type variables in scope),
  \item \lstinline|S| and \lstinline|T| are sequences of types of equal length,
        (usually the types of the actual arguments provided and the types of the parameters
        of the polymorphic function),
  \item \lstinline|R| is a result type (usually the return type of the polymorphic function),
  \item \lstinline|expected| is the expected type for R, or the value \lstinline|nil|,
\end{itemize}

and returns a \emph{substitution} that satisfies the following conditions:

\begin{itemize}
  \item Pairwise, each \lstinline|S| is a below \lstinline|T|,
  \item \lstinline|R| is below \lstinline|expected|, if \lstinline|expected| is provided.
\end{itemize}

A substitution maps type variables to types.
It is valid to replace all occurrences of the type variables named in the substitution 
with their associated type.
For example, substitution are often applied to \lstinline|R| by the caller of \lstinline|infer|
to eliminate the type variables in \lstinline|X| and \lstinline|Y|.

\lstinline|infer| is almost always used when invoking polymorphic functions.
\lstinline|clojure.core/constantly| is a polymorphic function with type \lstinline|(All [x y] [x -> [y * -> x]])|
(read as a function taking \lstinline|x| and returning a function that takes any number
of \lstinline|y|'s and returns \lstinline|x|).
For instance, \lstinline|((constantly true) 'any 'number)| results in the value \lstinline|true|.

Type checking the invocation \lstinline|(constantly true)|
calls \lstinline|infer| roughly like

\begin{lstlisting}
(infer {'x no-bounds 'y no-bounds}
       {}
       [(parse-type 'true)]
       [(make-F 'x)]
       (with-frees [(make-F 'x) (make-F 'y)]
         (parse-type '[y * -> x]))
       nil)
\end{lstlisting}

where the internal Typed Clojure bindings

\begin{itemize}
  \item \lstinline|no-bounds| is the type variable bounds with upper bound as \lstinline|Any|
    and lower bound as \lstinline|Nothing|,
  \item \lstinline|parse-type| is a function that takes type \emph{syntax} and converts it to a type (its argument must be quoted), 
  \item \lstinline|make-F| is a function that takes a name symbol and returns a type variable type of that name, and
  \item \lstinline|with-frees| is a macro that brings the type variables named in its first argument into scope in its second argument.
\end{itemize}

This returns a substitution that replaces occurrences of \lstinline|x| with \lstinline|true|
and \lstinline|y| with \lstinline|Any|.
This helps infer a result type of \lstinline|(constantly true)|
as \lstinline|[Any * -> true]|.

\section{F-Bounded Polymorphism}

A feature not present in Typed Racket is bounded polymorphism.
Several changes were needed to support bounded polymorphism. In every position
where a set of type variables was required, it was replaced by a map
of type variables to bounds.

Bounds consist of an upper and lower type bound, or a \emph{kind bound}.
Kind bounds are experimental following the inclusion of user definable type constructors
(motivated in section \ref{sec:monads}).
They are a stub for a more comprehensive treatment of higher-kinded operators
such as that described by Moors, Piessens, and Odersky for Scala~\cite{MPO08}.
At present, a type variable can only be instantiated to a type between
its upper and lower bounds, or, if a kind bound is defined instead, 
to a kind below the kind bound.

F-bounded polymorphism allows type variables to refer to themselves in their type bounds.
Bounds are checked after a substitution is generated, guaranteeing no substitution
can violate type variable bounds. To support F-bounds, the substitution being checked is applied to
the lower and upper bounds for each type variable, and the type associated with the type variable 
in the substitution is checked to be between these bounds.

\section{Variable-arity Polymorphism}

Variable-arity polymorphism in Typed Clojure is directly ported from Typed Racket.
This was the most complicated part of the prototype. At the center of the implementation
is manipulating dotted type variables, which can represent a sequence of types.

It also required changes to the polymorphic type inference, where each
reference to a type variable required a special case for a dotted type variable.
For example, the constraint-generation algorithm for Local Type Inference
features extra kinds of constraints for dotted variables.
Strickland, Tobin-Hochstadt, and Felleisen elaborate on the particular changes
required for the Typed Racket implementation~\cite{STF09}.

Porting Typed Racket's variable-arity polymorphism implementation was
tedious because some of the relevant internal functions interact
in strange ways with the rest of Typed Racket. My reaction was that Typed Racket
was initially designed without variable-arity polymorphism and was added
without major changes to other components. Typed Clojure was
developed with the same design so full variable-arity polymorphism
implementation could be ported without change.

\section{Portability to other Clojure Dialects}

Typed Clojure was built for the Clojure programming language, whose compiler
and data structures are implementated in Java. Clojurescript is the first major Clojure dialect
to be written in Clojure, and it is likely future dialects of Clojure will follow this example. 
Where Clojure uses Java Classes and Interfaces, 
Clojurescript's compiler and data structures are written in terms of Clojure's
two core abstractions: protocols and datatypes.
It would desirable to port Typed Clojure to similar  Clojure dialects while keeping
the core of the implementation constant.

A significant portion of Typed Clojure is theoretically platform independent but there are
challenges to targeting new dialects, including incompatible host interoperability and
non-standardised abstract syntax trees.
The first issue is predictable due to a core philosophy of Clojure dialects: 
host interoperability is non-portable\footnote{See the complete Clojure rationale: http://clojure.org/rationale}.
Each dialect of Clojure has a unique host interoperability story and Typed Clojure should cater for them
separately.
The second issue is potentially resolvable either by enforcing a standard representation for 
abstract syntax trees across Clojure implementations, or developing a library that provided
a common interface to abstract syntax trees for each Clojure implementation.

\section{Proposition Inference for Functions}
\label{sec:filterneg}

A feature not yet implemented in Typed Racket is the ability
to infer new propositions based on existing propositions of a function.
This feature was added to Typed Clojure to support filtering
a sequence based on negative information, such as filtering values
that are \emph{not} \lstinline|nil|.

\begin{lstlisting}[caption=Type annotation for filter, label=lst:filterann]
(ann clojure.core/filter 
  (All [x y]
    [[x -> Any :filters {:then (is y 0)}] (U nil (Seqable x)) -> (Seqable y)]))
\end{lstlisting}

To better understand the problem, listing \ref{lst:filterann} presents the type of \lstinline|filter|,
which takes a function \lstinline|f| and a sequence \lstinline|s| as arguments, and returns a sequence that 
contains each element in \lstinline|s| such that applying \lstinline|f| to the element returns a true value.
The \lstinline|:filters| syntax requires some explanation. 
Function types support an optional \emph{filter set} attached to its return type, written as a map
with \lstinline|:then| and/or \lstinline|:else| keys (if omitted, they default to the trivially true proposition which has no effect). 
The ``then-proposition'' and ``else-proposition'' are added
to the type environment when the return value is a true and false value respectively.
For example, the filter set \lstinline|{:then (is y 0)}| is read ``if the return value is a true value, then the first argument
must be of type y, otherwise if it is a false value, nothing interesting is enforced''
The type given for \lstinline|filter| works because the type variable
\lstinline|y| occurs in both the ``then-proposition'' of the first argument and the return type 
\lstinline|(Seqable y)|.

\begin{lstlisting}[caption=Troublesome filter, label=lst:filtertrouble]
(filter (fn [a] (not (nil? a))) coll)|
\end{lstlisting}

The difficulty starts with something like listing \ref{lst:filtertrouble},
where the inferred filter set for the first argument to \lstinline|filter|
is \lstinline|{:then (! nil 0) :else (is nil 0)}|\footnote{(! nil 0) is the proposition that the first argument is \emph{not}
of type \lstinline|nil|.}. The ``then-proposition'' \lstinline|(! nil 0)| does not fit with
\lstinline|(is y 0)| that \lstinline|filter| expects.

We can sometimes get around this if we already have a predicate with a positive
``then-proposition''. For example, if we are filtering out \lstinline|nil| values
from a sequence of type \lstinline|(Seqable (U Number nil))|, we can replace
listing \ref{lst:filtertrouble} with \lstinline|(filter number? coll)|,
where \lstinline|number?| has the filter set \lstinline|{:then (is Number 0) :else (! Number 0)}|.
This does not work, however, when filtering a sequence of type like \lstinline|(Seqable (U x nil))|
for some unspecified \lstinline|x| because there is no built-in predicate with ``then-proposition''
\lstinline|(is x 0)|.

\begin{lstlisting}[caption=Filtering with negative propositions, label=lst:filtergood]
  (filter (ann-form 
            #(not (nil? %))
            [(U nil x) -> boolean :filters {:then (is x 0)}])
          mvs)
\end{lstlisting}

Instead, we generate new propositions using a technique 
suggested by Tobin-Hochstadt~\cite{Tob12},
that follows from the occurrence typing calculus defined 
by Tobin-Hochstadt and Felleisen~\cite{TF10}.
First the filter set for functions are inferred as usual.
To collect new propositions, the ``then-proposition'' is applied to the type environment (which maps
local bindings to types). Any types associated with bindings that are changed after this
are represented as new propositions, which are added to the ``then-proposition'' for this filter set.
The same procedure is followed for the ``else-proposition''.

Using this technique, the anonymous function in listing 
\ref{lst:filtergood}\footnote{The Clojure syntax \lstinline|#(not (nil? \%))| 
is equivalent to \lstinline|(fn [a] (not (nil? a)))|}
has the filter set \lstinline|{:then (& (! nil 0) (is x 0)) :else (is nil 0)}|
which is good enough to infer the \lstinline|filter|ed result as \lstinline|(Seqable x)|.

Further work in this area is needed when filtering on a non-anonymous function.
For example, it is not clear how to infer the common idiom \lstinline|(filter identity coll)|
as returning a sequence of non-nil elements, for any sequence \lstinline|coll|.
Inferring new propositions for already existing functions like \lstinline|identity|
does not fit with Tobin-Hochstadt and Felleisen's calculus~\cite{TF10},
confirmed by Tobin-Hochstadt~\cite{Tob12} as future work in this area.

%\section{Non-hygienic Macro Expansion and Filters}


% need to remove bindings as they fall out of scope
% Need hygiene to ensure correct propagation of filters
%(fn [a]
%  (if (= a 1)
%    (let [a 'foo] ; here this shadows the argument, impossible to recover filters
%      a)          ; in fact any new filters about a will be incorrectly assumed to be the argument
%      false))
