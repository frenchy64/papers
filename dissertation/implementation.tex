\chapter{Implementation}

This chapter discusses the implementation of the Typed Clojure prototype type 
system\footnote{We refer to this implementation as \emph{Typed Clojure} for the remainder of this chapter.}
in some detail concentrating on significant challenges that were identified and overcome.
Many aspects of Typed Clojure's design follows the implementation of Typed Racket,
which is reflected in this chapter.

\section{Type Checking Procedure}

Typed Clojure and Typed Racket differ significantly in how they perform type checking.
Typed Racket is implemented as a language on the
Racket platform, which provides highly sophisticated and extensible macro facilities.
Interestingly, this allows Typed Racket to be entirely implemented with macros.
Instead, Typed Clojure is implemented as a library that utilises abstract syntax trees (AST)
generated by analyze\footnote{https://github.com/frenchy64/analyze}, a library I developed for this project.
This strategy follows common practice for Clojure projects, which favours providing modular libraries 
over modifying the language.

This section goes into details on the implementation of Typed Clojure.
First, a high-level overview is given on the type checking procedure.
Then the interfaces to particular high-level functions are discussed.

\subsection{General Overview}

There are several stages to type checking in Typed Clojure.
Type checking is typically initiated at the read-eval-print-loop prompt (REPL),
for example \lstinline|(check-ns 'my.ns)| checks the namespace \lstinline|my.ns|.
Before type checking begins, all global type definitions in the namespace
are added to the global type environment by compiling the namespace.
These type definitions include

\begin{itemize}
  \item type alias definitions
  \item var, protocol, datatype, and Java Class annotations
  \item Java method annotations, such as \lstinline|nilable-param| and \lstinline|non-nil-return|
\end{itemize}

An AST is then generated from the code contained in the target namespace.
This AST is then recursively descended and is type checked using local type inference.
Currently only one error is reported at a time, and type checking stops if a type error
is found.

\subsection{Bidirectional Checking}

The interface to the bidirectional checking algorithm is \lstinline|typed.core/check|,
which takes an expression, represented as an AST generated from \emph{analyze}, and an optional expected type for
the given expression. If the expected type is present, the bidirectional algorithm \emph{checks}
that the expected type matches the actual type of the expression.
If the expected type is omitted, a type is instead \emph{synthesised} for the expression.
The algorithm is based on Pierce and Turner's  Local Type Inference\cite{PT00}
and the implementation is similar in shape to Typed Racket's\cite{TF08}, in that
one function with an extra ``expected type'' argument is preferred over two complementary
functions, one for checking and one for synthesis.

The main difference between Typed Clojure's and Typed Racket's bidirectional checking
algorithm is the representation for expressions. Typed Racket relies on pre-existing
Racket features like syntax objects for expression representation. Clojure instead
leans towards abstract syntax tree representation, despite its Lisp heritages.
In terms of the bidirectional check, the difference is mostly cosmetic.


% go into more detail
% - update env
% - what is an environment? Bindings + propositions
% - LOC
% - link to github
% - how occurrence typing works
%   - update env
%   - how to calculate reachability 

\subsection{Occurrence typing}

Typed Clojure's implementation of occurrence typing is ported and extended from Typed Racket.
Occurrence typing plays several roles in Typed Clojure.
First, occurrence typing is used to update the type environment at every conditional branch.
Second, it is used to calculate whether branches are reachable.
Third, paths are used extensively in Typed Clojure. 
The implementation of these features are discussed in this section.

The basic idea of occurrence typing involves keeping a separate environment of \emph{propositions}
that relate bindings to types. These propositions are then used to update the type environment.
In Typed Clojure there are several types of propositions, referred to as \emph{filters}.
They are based on the theory by Tobin-Hochstadt and Felleisen\cite{TF10}, and are ported directly
from Typed Racket.


\begin{itemize}
  \item TopFilter and BotFilter represent the trivially true and trivially false propositions respectively.
  \item TypeFilter and NotTypeFilter represent a positive or negative association of a binding name
        to a type. The syntax \lstinline|(is t name)|
  \item AndFilter and OrFilter represent logical conjunction and disjunction of propositions.
\end{itemize}

Propositions can optionally carry \emph{path} information
represented by a sequence of \emph{path elements}, which signify which part
of the binding's type to update. For example, Typed Racket uses \emph{car} and \emph{cdr} path elements
to track which component of a cons type to update.
Paths are particularly useful in Typed Clojure. There are path elements for traversing heterogeneous map types (KeyPE),
inferring length information (CountPE), and \lstinline|first| and \lstinline|rest| paths for sequences.
These additions do not appear to introduce any significant new complexities related to paths.

\section{Polymorphic Type Inference}

The polymorphic type inference algorithm is directly ported from Typed Racket with slight extensions
for bounded variables,
and is reminiscent to Pierce and Turner's Local Type Inference\cite{PT00}.
A common entry point for inferring type variables to polymorphic function invocations
\lstinline|typed.core/infer|.

\lstinline|infer| is invoked like \lstinline|(infer X Y S T R expected)|, where

\begin{itemize}
  \item \lstinline|X| is a map from type variable names
        to their bounds (representing the type variables in scope),
  \item \lstinline|Y| is a map from type variable names
        to their bounds (representing the \emph{dotted} type variables in scope),
  \item \lstinline|S| and \lstinline|T| are sequences of types of equal length
  \item \lstinline|R| is a type,
  \item \lstinline|expected| is the expected type for R, or the value \lstinline|nil|,
\end{itemize}

and returns a \emph{substitution} that satisfies the following conditions:

\begin{itemize}
  \item Pairwise, each \lstinline|S| is a below \lstinline|T|,
  \item \lstinline|R| is below \lstinline|expected|, if \lstinline|expected| is provided.
\end{itemize}

A substitution maps type variables to an upper and lower bound. 
It is valid to replace all occurrences of the type variables named in the substitution 
with a type between their associated bounds.
For example, usually the substitution is applied to \lstinline|R| by the caller of \lstinline|infer|.
Whether to substitute the upper or lower bound is determined by the variance
of the type variable in relation to the type being substituted. 
The specific algorithm is described in Local Type Inference.

\section{F-Bounded Polymorphism}

A feature not present in Typed Racket is bounded polymorphism.
Several changes were needed to support bounded polymorphism. In every position
where a set of type variables was required, it was replaced by a map
of type variables to bounds.

Bounds consist of an upper and lower type bound, or a \emph{kind bound}.
Kind bounds are experimental following the inclusion of user definable type constructors
(motivated in section \ref{sec:monads}).
They are a stub for a more comprehensive treatment of higher-kinded operators
such as that described by Moors, Piessens, and Odersky for Scala\cite{MPO08}.
At present, a type variable can only be instantiated to a type between
its upper and lower bounds, or, if a kind bound is defined instead, 
to a kind below the kind bound.

F-bounded polymorphism allows type variables to refer to themselves in their bounds.

\section{Variable-arity Polymorphism}

Variable-arity polymorphism in Typed Clojure is directly ported from Typed Racket.
This was the most complicated part of the prototype. At the center of the implementation
is manipulating dotted type variables, which can represent a sequence of types.

It also required changes to the polymorphic type inference algorithm.
The constraint-generation portion 

\section{Portability to other Clojure Dialects}

Typed Clojure was built for the Clojure programming language, whose compiler
and data structures are implementated in Java. Clojurescript is the first major Clojure dialect
to be written in Clojure, and it is likely future dialects of Clojure will follow this example. 
Where Clojure uses Java Classes and Interfaces, 
Clojurescript's compiler and data structures are written in terms of Clojure's
two core abstractions: protocols and datatypes.
It would desirable to port Typed Clojure to similar  Clojure dialects while keeping
the core of the implementation constant.

A significant portion of Typed Clojure is theoretically platform independent but there are
challenges to targeting new dialects, including incompatible host interoperability and
non-standardised abstract syntax trees.
The first issue is predictable due to a core philosophy of Clojure dialects: 
host interoperability is non-portable\footnote{See the complete Clojure rationale: http://clojure.org/rationale}.
Each dialect of Clojure has a unique host interoperability story and Typed Clojure should cater for them
separately.
The second issue is potentially resolvable either by enforcing a standard representation for 
abstract syntax trees across Clojure implementations, or developing a library that provided
a common interface to abstract syntax trees for each Clojure implementation.

\section{Composite Propositions}

\section{Non-hygienic Macro Expansion and Filters}
% need to remove bindings as they fall out of scope
% Need hygiene to ensure correct propagation of filters
%(fn [a]
%  (if (= a 1)
%    (let [a 'foo] ; here this shadows the argument, impossible to recover filters
%      a)          ; in fact any new filters about a will be incorrectly assumed to be the argument
%      false))

\section{Filtering on Negative Propositions}
\label{sec:filterneg}
