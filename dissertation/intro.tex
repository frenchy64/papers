\chapter{Introduction}

\section{Thesis}

\emph{It is practical and useful to design and implement an optional typing system 
for the Clojure programming language that allows Clojure programmers to continue 
using idioms and style found in current Clojure code.}

\section{Motivation}

% Type Systems for lisp?
% Why type systems?
% Why Clojure?

In the last decade it has become increasingly common to enhance
dynamically typed languages with static type systems. 
This idea not new, but recent attempts are noteworthy for their successful use of bidirectional checking\footnote{These 
slides by Felleisen, a practitioner in this area for over 20 years, present a history of optional type checking
for Lisp/Scheme that spans around 40 years\cite{Fell09}}.
Instead of always attempting to infer types the algorithm relies on programmer annotations
appearing in some natural places, such as giving the type of each top-level function.

The Clojure programming language is a dynamically typed dialect of Lisp invented
by Hickey, designed to run on popular platforms\footnote{http://clojure.org/}.
It emphasises functional programming with immutable data structures
and provides direct interoperability with its host platform.
Notable implementations of Clojure exist for the Java Virtual Machine (JVM),
the Common Language Runtime, and for Javascript virtual machines.
At the current time, Clojure on the JVM is the most mature implementation,
and therefore this project focuses on the JVM implementation.

Clojure has attracted wide-spread users in part by concentrating on pragmatism.
Performance is a key feature, for example the JVM implementation of Clojure
offers ways to access Java-like speed for certain operations.
Also, Clojure's excellent host interoperability offers Clojure programmers
access to existing libraries for their platform, such as the extensive Java library ecosystem.
By coupling pragmatic necessities with elegant features like Lisp, functional programming,
and immutability by default, Clojure is a compelling general purpose programming language.

Recently languages have been created to or been modified to support aspects
of both static and dynamic typing.
Dart\footnote{http://www.dartlang.org/} is dynamically typed but offers optional type annotations
that do not affect runtime semantics. 
Typescript\footnote{http://www.typescriptlang.org/} adds an optional type system to Javascript,
a well-known dynamic language.

When a static type checker is not available, which describes the situation
for most dynamic languages, other techniques are used for checking
type invariants. For example, ``design by contract'' is often used,
introduced by Meyer for the Eiffel language\cite{Mey92},
in which the programmer defines contracts that are enforced at runtime.
Unit testing is also a popular verification technique in dynamic languages.
Clojure adopts these approaches, providing easy syntax for defining 
Eiffel-inspired pre- and post-conditions and a library for writing unit tests.

Static type systems, however, are still desirable for certain situations.
Powerful type systems like ML's\cite{Mil97} and Haskell's\cite{Mar10} have proved particularly useful
for writing in complicated programming styles. For example,
Haskell's advanced static type system helps the programmer write correct monadic code,
especially in more complicated situations like combining monads via monad transformers.

\subsection{Why implement an optional type system for Clojure?}

The initial motivation for implementing an optional type system
for Clojure occurred during an anecdotal account of the struggles
of a Clojure programmer. In a heroic effort, he managed to 
implement a library for conduits (or \emph{arrows}) in Clojure, 
which probably surpass monads in complexity, and is usually reserved
for languages with advanced type systems like Haskell.

He highlighted a strong desire for a type system for several reasons.
Firstly, to verify the correctness
of the library (before noting that unit tests and runtime contracts
were insufficient for this task).
Secondly, to aid him while writing the library.

Since then, the Clojure community has shown interest in this work.
I developed this project as a Google Summer of Code 2012 project,
after it was selected by the Clojure community.
I have also been invited to speak on this project at the Clojure Conj
2012 conference, a major annual Clojure conference.

\subsection{What kind of type system does Typed Clojure provide?}

% refinements check invariants of programs
% while ordinary static types check whether programs
% are basically meaningful - Rowan + Frank P
% Page 1 Rowan's PhD

There are many concepts associated with \emph{types} and \emph{type systems} in both the
literature and informal discourse.
A programmer who uses dynamically-typed languages may have a drastically different notion
of what a type is than, say, a programmer preferring languages with advanced static type systems.
There is some debate as to whether optional static type systems like Typed Clojure
can even be called a type system. We choose to
follow the terminology of Pfenning\cite{Pfe08} and Reynolds\cite{Rey01},
where such optional type systems are \emph{extrinsic} type systems, and more
traditional type systems are \emph{intrinsic} type systems.

An ordinary static type system is used to check whether programs are basically
meaningful. Pfenning and Reynolds call these type systems \emph{intrinsic}. A language with an intrinsic
static type system has run-time semantics that depends on the types of associated
variables and expressions during type checking.
For example, C, Java, and ML have intrinsic types.
This means programs written in these languages must pass the type checker before being run.

A static type system is \emph{extrinsic} when runtime semantics
does not depend on the type system. In other words, passing a static type checker
is not essential to running programs. A dynamically typed language can be viewed
as having a trivial static type system that supports exact one type,
a view strongly advocated by Harper\cite{Har12}
and common in the literature on static types (for example, Pierce\cite{Pie02}).

\section{Typed Clojure through Examples}

% Hello world
This section introduces Typed Clojure with example code. 
Typed Clojure is developed for the JVM implementation of Clojure, therefore
the rest of this chapter uses that implementation.
An attempt is
made to introduce some Clojure syntax and semantics to those unfamiliar or needing a refresher.
A basic knowledge of Lisp syntax is handy, but a brief tutorial is given
for newcomers.

\subsection{Preliminary: Lisp Syntax}

The core of understanding Lisp syntax when coming from a popular language
like Java or Javascript can be summarised by these points.

\begin{itemize}
  \item Operators are always in prefix position.
  \item Invocations are always wrapped in a pair of balanced parenthesis.
  \item Parenthesis start to the left of the operator.
\end{itemize}

For example, the Java expressions \emph{1 + 2 / 3} is written in Lisp pseudocode \lstinline|(/ (+ 1 2) 3)|
and \emph{numberCrunch(1, 2)} written \lstinline|(numberCrunch 1 2)|.

Clojure also adds other syntax:

\begin{itemize}
  \item Prefixing \lstinline|:| to a symbol defines a \emph{keyword}, often used for map keys. eg. \lstinline|:my-keyword|.
  \item Square brackets delimit vector literals. eg. \lstinline|[1 2]| is a 2 place vector.
  \item Curly brackets define map literals. eg. \lstinline|{:a 1 :b 2}| is a map from 
        \lstinline|:a| to \lstinline|1| and \lstinline|:b| to \lstinline|2|.
  \item Commas are always optional, and treated as whitespace.
\end{itemize}

\subsection{Simple Examples}

We begin with the obligatory \emph{Hello world} example.

\begin{lstlisting}[caption=Typed Hello world, label=lst:helloworld]
(ns typed.test.hello-world
  (:require [typed.core :refer [check-ns]]]))

(println "Hello world")
\end{lstlisting}

At this point, it is worth understanding Clojure's namespacing feature.
Clojure code is always executed in a \emph{namespace}, and each file of Clojure code should 
have a \lstinline|ns| declaration with the namespace name and its dependencies,
which switches the current namespace and executes the given dependency commands.
There is one special namespace, \lstinline|clojure.core| which is
loaded with every namespace, implicitly ``referring'' all its vars in the namespace.
For example, \lstinline|ns| refers to the var \lstinline|clojure.core/ns|,
similarly \lstinline|println| refers to \lstinline|clojure.core/println|.

The example in listing \ref{lst:helloworld} declares a dependency to 
\lstinline|typed.core|, Typed Clojure's main namespace. It also refers the var \lstinline|typed.core/check-ns|
into scope\footnote{\lstinline|check-ns| is the top level function for type checking a namespace}.
Other than this dependency, this is identical to the untyped \emph{Hello world}.

More complex code require extra annotations to type check:

\begin{lstlisting}[caption=Annotating vars in Typed Clojure]
(ns typed.test.collatz
  (:require [typed.core :refer [check-ns ann]]))

(ann collatz [Number -> Number])
(defn collatz [n]
  (cond
    (= 1 n) 
      1
    (and (integer? n) 
         (even? n)) 
      (collatz (/ n 2))
    :else 
      (collatz (inc (* 3 n)))))
\end{lstlisting}
\footnote{Example adapted from Tobin-Hochstadt \cite{Tob10}}

In this example, we define a new var \lstinline|typed.test.collatz/collatz|. Typed Clojure requires all 
used vars to be annotated. Here \lstinline|typed.core/ann| annotates \lstinline|typed.test.collatz/collatz|
to be a function from \lstinline{java.lang.Number} to 
\lstinline{java.lang.Number}\footnote{All Classes in the \lstinline|java.lang| package
are automatically imported in every Clojure namespace (the equivalent of Java's \lstinline|import java.lang.*;|).}.

\subsection{Datatypes and Protocols}

We can annotate datatype and protocol definitions similarly.

\begin{lstlisting}[caption=Annotating protocols and datatypes in Typed Clojure]
(ns typed.test.deftype
  (:require [typed.core 
             :refer [check-ns ann-datatype
                     tc-ignore ann-protocol AnyInteger]]))

(ann-protocol Age 
  :methods
  {age [Age -> AnyInteger]})
(tc-ignore
  (defprotocol Age
    (age [this])))

(ann-datatype Person 
  [[name :- String]
   [age :- AnyInteger]])
(deftype Person [name age]
  Age
  (age [this] age))

(age (Person. "Lucy" 34))
\end{lstlisting}

\lstinline|clojure.core/defprotocol| defines a new Clojure protocol\footnote{See http://clojure.org/protocols for a full description of protocols}
with a set of methods. \lstinline|typed.core/ann-protocol| annotates a protocol with the types of its methods.
In this example, we define a protocol \lstinline|typed.test.person/Age| with an \lstinline|age| method.
The call to \lstinline|clojure.core/defprotocol| also defines a new var \lstinline|typed.test.person/age|, a first-class function
wrapping the \lstinline|age| method, but taking the target Object as the first parameter. The
type signature provided with \lstinline|typed.core/ann-protocol|, here \lstinline|[typed.test.person/Age -> typed.core/AnyInteger]|, 
is for this function.

Invocations of \lstinline|clojure.core/defprotocol| are currently not able to be type checked
and are ignored by Typed Clojure by passing them to \lstinline|typed.core/tc-ignore|.

\lstinline|clojure.core/deftype|
defines a new Clojure datatype\footnote{See http://clojure.org/datatypes for a full description of datatypes}
in the current namespace with a number of fields and methods. 
\lstinline|typed.core/ann-datatype| annotates a datatype with its field types.
In this example, we create a datatype \lstinline|typed.test.person.Person|
with fields \lstinline|name| and \lstinline|age| and implement the \lstinline|age|
method from protocol \lstinline|typed.test.person/Age|.

Java constructors are invoked in Clojure by suffixing the Class we want to instantiate with a dot.
Datatypes are implemented as Java Classes with immutable fields (by default) and a single constructor, taking as arguments its fields 
in the order they are passed to \lstinline|deftype|
\footnote{When unambiguous, I omit the qualifying namespace/package for the remainder of the chapter.}.
\lstinline|(Person. "Lucy" 34)| constructs a new \lstinline|Person|
instance, setting the fields to their corresponding positional arguments.
Typed Clojure checks the datatype constructor to be the equivalent of 
\lstinline|[String AnyInteger -> Person]|.

Finally, Typed Clojure checks invocations of Protocol methods. It infers \lstinline|Person|
is an instance of \lstinline|Age| from the datatype definition, therefore \lstinline|(age (Person. "Lucy" 34))| is type-safe.

\subsection{Polymorphism}

Typed Clojure supports F-bounded polymorphism. All type variables may have
upper and lower bounds.

Typed Clojure parameterises some of Clojure's data structures. For example,
the interface behind Clojure's \emph{seq} abstraction \lstinline|clojure.lang.Seqable| has one 
covariant parameter\footnote{\lstinline|(Seqable Integer)| being a subtype of \lstinline|(Seqable Number)|
because Integer is a subtype of Number.}.

\begin{lstlisting}[caption=Polymorphism in Typed Clojure]
...
(ann to-set 
     (All [x]
       [(U nil (Seqable x)) -> (clojure.lang.PersistentHashSet x)]))
(defn to-set [a]
  (set a))
...
\end{lstlisting}

In this example\footnote{When convenient, namespace declarations are omitted for the remainder of the chapter.}, 
we define \lstinline|to-set|, aliasing \lstinline|clojure.core/set|.
\lstinline|All| introduces a set of type variables to the body of a type,
here \lstinline|x| is used to define a relationship between the input type and return type.

\lstinline|(U nil (Seqable x))| is a common type in Typed Clojure, read as the union
of the type \lstinline|nil| and the type \lstinline|(Seqable x)|.
The vast majority of types for collection processing functions in the Clojure core library feature
it as an input type, where passing \lstinline|nil| either has some special behaviour 
or is synonymous with passing an empty \lstinline|Seqable|.

\subsection{Heterogeneous Maps}

Where particularly object-oriented languages reach for objects, Clojure
utilises maps. Clojure provides a map literal using curly braces. For example,
\lstinline|{:a 1, :b 2}| is a map with two key-value entries: from Keyword key \lstinline|:a|
to value \lstinline|1|, and Keyword key \lstinline|:b| to value \lstinline|2|. Note that commas are always
whitespace in Clojure and are included for readability.

Typed Clojure provides a heterogeneous map type, restricted to 
maps with singleton Keyword keys. This restriction is reflected
in the syntax for defining heterogeneous map types.

\begin{lstlisting}[caption=Heterogeneous map types in Typed Clojure]
...
(ann config
     (HMap {:file String,
            :ns Symbol}))
(def config
  {:file "clojure/core.clj",
   :ns 'clojure.core})
...
\end{lstlisting}

This example checks \lstinline|config| to be a heterogeneous map
with \lstinline|:file| and \lstinline|:ns| keys, with values of
type \lstinline|String| and \lstinline|Symbol| respectively.

Heterogeneous vector and seq types are also provided.

\subsection{Multi-Arity Functions}

Clojure function objects support multiple arities, allowing dispatch
on the number of supplied arguments.

\begin{lstlisting}[caption=Annotating multi-arity functions in Typed Clojure]
(ns typed.test.poly
  (:require [typed.core :refer [ann AnyInteger check-ns cf]])
  (:import [clojure.lang Seqable]))

(ann repeatedly'
     (All [x]
       (Fn [[-> x] -> (Seqable x)]
           [AnyInteger [-> x] -> (Seqable x)])))
(defn repeatedly'
  "Takes a function of no args, presumably with side effects, and
  returns an infinite (or length n if supplied) lazy sequence of calls
  to it"
  ([f] (lazy-seq (cons (f) (repeatedly' f))))
  ([n f] (take n (repeatedly' f))))
\end{lstlisting}

This example defines \lstinline|repeatedly'|\footnote{Identical to \lstinline|clojure.core/repeatedly|},
a multi-arity function taking either a zero-argument function, or an integer and a zero-argument function as arguments.
The type variable \lstinline|x| links the return type of the generator function to
the resulting \lstinline|Seqable| instance.

When checking the definition of multi-arity functions, Typed Clojure
finds the matching function types for a particular arity by number of arguments
and requires each relevant type to check successfully.

\subsection{Variable-Arity Functions}

Clojure functions can take an optional \emph{rest} argument.

\subsubsection{Uniform Variable-Arity}

\subsubsection{Non-uniform Variable-Arity}

\subsection{Occurrence Typing}

Typed Clojure uses occurrence typing to improve inference\footnote{TODO occurrence typing reference}.
Occurrence typing is used to refine types for immutable local bindings 
as programs follow conditional branches.

\begin{lstlisting}[caption=Example of occurrence typing in Typed Clojure]
(ann num-vec2 
     [(U nil Number) (U nil Number) -> (Vector* Number Number)])
(defn num-vec2 [a b]
  [(if a a 0) 
   (if b b 0)])
\end{lstlisting}

To check this example, occurrence typing infers type information based on the result of each test.
In Clojure, \lstinline|nil| and \lstinline|false| are false values and all other values are true.
The test \lstinline|(if a a 0)| follows the \emph{then} branch is \lstinline|a| is not \lstinline|nil|
or \lstinline|false|. When checking this branch, we can safely refine the type of \lstinline|a| to \lstinline|Number| from
\lstinline|(U nil Number)|. Similarly, following the \emph{else} branch refines the type of \lstinline|a|
to \lstinline|nil| from \lstinline|(U nil Number)|.

\subsection{Java Interoperability}

Typed Clojure currently provides safe interop\footnote{Interop is short for interoperability} with (non-Generic) Java
\footnote{Compatibility with Generic Java is planned future work}.

The key to safe Java interop is the treatment of Java's \emph{null}.
\emph{null} is a subtype to all reference types
represented in Clojure by \lstinline|nil|. Unlike Java's type system
Clojure explicitly separates \emph{null} and reference types, allowing
Typed Clojure to express
\emph{nullable}
\footnote{A type is \emph{nullable} if it may also be an instance of \emph{null},
which is expressed in Typed Clojure by creating a union of the reference type and \lstinline|nil|.}
positions.

\begin{lstlisting}[caption=Java interoperability with Typed Clojure]
(ns typed.test.interop
  (:import (java.io File))
  (:require [typed.core :refer [ann non-nil-return check-ns]]))

(ann f File)
(def f (File. "a"))

(ann prt (U nil String))
(def prt (.getParent ^File f))

(non-nil-return java.io.File/getName :all)
(ann nme String)
(def nme (.getName ^File f))

\end{lstlisting}

This example shows how Typed Clojure handles \emph{null} while creating and
using an instance of \emph{java.io.File}\footnote{See Javadoc: http://docs.oracle.com/javase/1.4.2/docs/api/java/io/File.html}.

Typed Clojure checks calls to Java constructors by requiring the provided
arguments be acceptable input to at least one constructor for that Class.
In this case, \emph{java.io.File} has a constructor accepting a \emph{java.lang.String}
argument, so \lstinline|(File. "a")| is type safe. Java constructors never
return \emph{null}, so Typed Clojure assigns the return type to be \lstinline|File|.
This constructor is equivalent to \lstinline|[String -> File]| in Typed Clojure.

Next, we see how Typed Clojure's default behaviour treats method return positions as nullable.
The \emph{java.io.File} instance method \emph{getParent}
is equivalent to \lstinline|[-> (U nil String]| in Typed Clojure. This happens to be
a valid approximation of the method as \emph{getParent} returns \emph{null} 
``if the pathname does not name a parent directory''\footnote{See Javadoc: http://docs.oracle.com/javase/1.4.2/docs/api/java/io/File.html}.
On the other hand, the instance method \emph{getName} always returns an
instance of \emph{java.lang.String}, so we set the return position of
\emph{getName} to non-nil with \lstinline|typed.core/non-nil-return|
\footnote{The second parameter to \lstinline|non-nil-return| specifies which arities to assume non-nil 
returns, accepting either a set of parameter counts of the relevant arities, or \lstinline|:all|
to override all arities of that method.}.
