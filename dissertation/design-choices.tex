\chapter{Design Choices}

This chapter describes the design choices made for Typed Clojure.
Typed Clojure is designed to be of practical use to Clojure programmers.
To this end, many of the design choices are borrowed from other existing projects.
Some of the main design choices that specifically concern Typed Clojure are given more
more detailed descriptions.

\section{Typed Racket}

The majority of the design and implementation of Typed Clojure is based on Typed Racket~\cite{Tob10}.
This is a deliberate choice: the purpose of this work is to produce
a practical tool, and there is already good evidence that Typed Racket
is practical and makes good tradeoffs and design choices.
Our differences are mostly due to the differences between Clojure and Racket.
This section details some of these differences.

\subsection{Occurrence Typing}

Occurrence typing, described by Tobin-Hochstadt and Felleisen~\cite{TF10},
plays a major role in capturing many common Clojure idioms.
One important idiom it helps Typed Clojure to understand 
is the \emph{sequence abstraction}, which
is made up of the \lstinline|clojure.core| functions \lstinline|seq|, \lstinline|first|, and \lstinline|rest|.

\lstinline|seq| takes an argument that is either a sequence or \lstinline|nil|,
and returns a non-empty sequence if passed a non-empty sequence, or returns
\lstinline|nil| if passed an empty sequence or \lstinline|nil|.
It is a common idiom to test \lstinline|(seq coll)| in a conditional
to determine whether the sequence \lstinline|coll| is empty:
if \lstinline|(seq coll)| is a true value, then \lstinline|coll|
is non-empty, otherwise it should be considered empty.
Occurrence typing allows us to capture this idiom as shown in
listing \ref{lst:seqtype}.

\begin{lstlisting}[caption=Type assiciated with clojure.core/seq, label=lst:seqtype]
(All [x]
  [(U nil (Seqable x)) -> (U nil (Seqable x))
   :filters {:then (is (CountRange 1) 0)
             :else (| (is nil 0)
                      (is (ExactCount 0) 0))}])
\end{lstlisting}

This function type takes an argument of type \lstinline|(U nil (Seqable x))| (the syntax \lstinline[mathescape]{(U $\overrightarrow{t}$)}
constructs a union of types \lstinline|t|), and returns a type \lstinline|(U nil (Seqable x))|.
Occurrence typing allows us to attach propositions to the return
type of a function. Roughly, these say if \lstinline|(seq coll)|
returns a true value, then \lstinline|coll| is of type
\lstinline|(CountRange 1)| (a type representing a sequence of length 1 or greater),
otherwise \lstinline|coll| is \emph{either} of type \lstinline|nil| or of type \lstinline|(ExactCount 0)| (a type
representing an empty sequence).
(See section \ref{sec:filterneg} for a more detailed explanation of the filter syntax).

Correspondingly, \lstinline|first| which gets the first member of a sequence.
can be given a more accurate (and surprisingly subtle) type.
\lstinline|first| is overloaded in a similar fashion to \lstinline|seq|.
\lstinline|first| takes an argument that is either a sequence or \lstinline|nil|.
If it is passed \lstinline|nil| or an empty sequence, it returns \lstinline|nil|. Otherwise, if it is passed
non-empty sequence, it returns the first member of the sequence.
Listing \ref{lst:firsttype} shows the type of \lstinline|first|.

\begin{lstlisting}[caption=Type assiciated with clojure.core/first, label=lst:firsttype]
(All [x]
  (Fn [(U nil (I (Seqable x) (ExactCount 0))) -> nil]
      [(I (Seqable x) (CountRange 1)) -> x]
      [(U nil (Seqable x)) -> (U nil x)])))
\end{lstlisting}

The function type has three arities, the last of which can be considered a ``default'' arity.
The first two arities correspond exactly to the two cases described for when 
\lstinline|first| is passed an empty sequence or \lstinline|nil|, and
when \lstinline|first| is passed a non-empty sequence
(the syntax \lstinline[mathescape]{(I $\overrightarrow{t}$)}
constructs an intersection of types \lstinline|t|).

These two functions interact via occurrence typing.
For example, listing \ref{lst:seqocc} tests
\lstinline|(seq coll)| which means occurrences of \lstinline|coll|
in the ``then'' branch are non-empty and those in the
``else'' branch are empty.
We can safely call \lstinline|(.method (first coll))| in the ``then''
branch (assuming elements of \lstinline|coll| have a no-argument method called \lstinline|method|)
always avoiding a \emph{NullPointerException}.

\begin{lstlisting}[caption=Example of using the sequence abstraction with occurrence typing, label=lst:seqocc]
...
(let [coll (possibly-empty-coll)
  (if (seq coll)
    (.method (first coll))
    nil))
...
\end{lstlisting}

\subsection{Variable-arity Polymorphism}

%Tobin-Hochstadt 

% Problematic areas
% - flattened paired arguments. assoc, hash-maps, array-map
% - complex argument dependencies. comp, partial

\section{Safer Host Interoperability}
% Args non-nil, return nilable
% Constructors and other special methods handled appropriately (eg. Constructor are non-nil return)
% TODO refine language Clojure vs. Clojure JVM

% what is this paragraph saying?
Dialects of Clojure provide fast and unrestricted access to their host platform. 
This is a intentional source of incompatibility between Clojure implementations.
For example, Clojure is hosted on the Java Virtual Machine (JVM), ClojureCLR on the Common Language Runtime,
and ClojureScript on Javascript VMs. These are very different platforms, and it is unlikely
a Clojure dot call will be portable. There is no attempt at reconciling
host interoperability differences, and it is up to the programmer to decide
how to best abstract over different hosts.

Typed Clojure targets the JVM hosted Clojure.
Clojure embraces the JVM as a host by sharing its runtime type system and encouraging direct
interaction with libraries written in other JVM languages. Most commonly, Clojure programmers
reach to Java libraries. Java is statically typed language. It follows that any interaction with
Java will already have an annotated Java type. Typed Clojure can use these annotations
to statically type check these interactions.

Typed Clojure attempts to improve some shortcomings of Java's static type system.

Java's static type system does not provide a type-safe construct for eliminating
the \lstinline|null| pointer. Instead, Java programmers often rely on either testing
for \lstinline|null| or prior domain knowledge.

\begin{lstlisting}[caption=null elimination in Java]
...
Object a = nextObject();
if (a != null)
  parseNextObject(a);
else
  throw new Exception("null Pointer Found!);
...
\end{lstlisting}


In Java, \lstinline|null| is included in all reference
types, but \lstinline|null| is not expressible as a static type. In other words,
when a Java type claims a reference type, you should also assume it can also be of 
type \lstinline|null|.

Scala provides the Option type for safe \lstinline|null| elimination, forcing pattern matching
where \lstinline|null| might occur. This approach is not appropriate for Typed Clojure
as pattern matching is not idiomatic in Clojure.

\subsection{Primitive Arrays}

% Primitive arrays are covariant, which is well-known to be statically unsound.
% We cannot trust the type signature of any Java method or field.
% Separate read and write types into two parameters.

\subsection{Interaction with null}
\label{sec:interactionnull}

It is a goal of Typed Clojure to statically prevent many Java \emph{NullPointerException}
exceptions.
\emph{null} is explicitly expressible in Typed Clojure as the singleton type \lstinline|nil|,
representing the \emph{value} \lstinline|nil|.
This enables more expressive types that specify where \emph{nil} is and is not allowed.
Section \ref{sec:javainterop} gives an example of how this could be useful 
when using Java interoperability and gives details on the different ways Typed Clojure.

Occurrence typing~\cite{TF10} also plays a crucial role in Typed Clojure's
treatment of \lstinline|nil|.
It allows us to track whether particular bindings are possibly \lstinline|nil|
down conditional branches, and makes it practical to throw type errors 
where \lstinline|nil| is not allowed (see section \label{sec:OccurrenceTyping} for examples).
This is not practical in Java's type system because \emph{null} is not directly
expressible, which makes it impractical to error when a \emph{NullPointerException}
exception is possible: according to the type system, almost every operation
could involve \emph{null}!
Eliminating \emph{NullPointerException} exceptions is entirely the programmers
responsibility in Java.
Typed Clojure helps the programmer by statically proving certain misuses of \lstinline|nil| are impossible.

The design choice of potentially misusing \lstinline|nil| results in a type error
needs further work to be completely satisfying.
Certain cases of type inference should be improved to avoid redundant code
that ``pleases the type checker''.
For example, we currently do not know how to infer \lstinline|(filter identity coll)|
as returning a sequence of non-nil elements, for any sequence \lstinline|coll|.
(see section \ref{sec:filterneg}).
It is also possible for code interacting with Java to introduce unexpected \emph{null}
values. Currently, we let the programmer define a set of unenforced \emph{assumptions}
where \emph{null} is allowed in Java fields and methods (see section \label{sec:javainterop}).
Adding runtime assertions that enforce these assumptions would allow more
accurate errors, an approach similar to that taken by Typed Racket~\cite{Tob10} when
interfacing with untyped Racket code.

\section{Clojure Hierarchy}

The Clojure hierarchy is a set of Java classes and interfaces, mostly in the
\emph{clojure.lang} package, that define Clojure's core 
interfaces and data structures.
Typed Clojure parameterises some of these classes in a way that resembles
Java or Scala generics.

Clojure's hierarchy was accommodating to this process.
For example, \lstinline{clojure.lang.Seqable} is the main interface behind
Clojure's sequence abstraction. Sequences are immutable collections,
so it was natural to parameterise \lstinline{Seqable} with one covariant
argument (covariant means \lstinline|(Seqable Integer)| is
a subtype of \lstinline|(Seqable Number)| because \lstinline|Integer|
is a subtype of \lstinline|Number|).
All ``seqable'' classes in the Clojure hierarchy implement \lstinline|Seqable|,
so updating them to use the parameterised \lstinline|Seqable| was a matter of
searching for classes that had \lstinline|Seqable| as an ancestor and replacing
the unparameterised \lstinline|Seqable| with the corresponding parameterised 
version.

Defining new ``parameterised'' versions of existing classes and interfaces do 
not affect anything outside Typed Clojure.
They are only for use by Typed Clojure.

\section{Protocols and Datatypes}

Protocols and datatypes are two of Clojure's main means of abstraction.


%section \ref{sec:datatypes}

\section{Local Type Inference}

Typed Clojure takes a

Similar to Typed Racket, type inference is based on Local Type Inference
by Pierce and Turner~\cite{PT00}.

\section{F-bounded Polymorphism}

Typed Clojure includes support for F-bounds on type variables\cite{CCHOM89}, as an extension
to Local Type Inference. 

An extra environment from type variables to bounds is kept until after inference,
after which each unground bound is substituted with the inferred types and the
subtyping relationships are checked.

\section{Heterogeneous Maps}
\label{ref:designhmap}
% keyword keys for now, generally encouraged, fast
% Some heterogeneous maps have string args, eg. from web frameworks

Heterogeneous maps in Typed Clojure are simple enough to avoid
the complications associated with concatenable records (section \ref{sec:recordtypes})
while still supporting many Clojure idioms.
They support adding new entries with keyword keys, removing entries,
and lookup of keyword keys.
When using these operations with non-keyword keys, heterogeneous maps
are treated like plain hash-maps.

They do not support concatenation (merging), as heterogeneous maps
only hold positive information on the keys with entries, not
which keys are \emph{absent}.
This makes concatenation unsafe, as keys to the right of a
concatentation can ``overwrite'' keys to the left. With no information
on the absence of keys, concatenation becomes an unsound operation.

We formalised some aspects of the behaviour of heterogeneous map types in Appendix~\ref{sec:hmaptheory}.
This also serves as a prototype for formalising other aspects in the future.
Here we give a formal syntax, operational semantics and type system using inference
rules, as is standard in the programming language community (see, eg., Pierce~\cite{Pie02}).

%\subsection{Higher-order Variable-arity Polymorphism (SKETCH)}
%
%Practical Variable-arity Polymorphism introduces the concept of a dotted type parameter,
%representing a sequence of types, allowing non-uniform variable parameters.
%This enables \lstinline|map| and other function with complex arguments to be typed.
%Strickland, Tobin-Hochstadt, and Felleisen's approach is solves almost all variable-arity applications in
%Typed Racket, and is a key feature of Typed Racket's implementation.
%
%Idiomatic variable-arity functions in Clojure's are even more sophisticated than Typed Racket, requiring extensions
%to Typed Racket's approach to type check satisfactorily. The Clojure core library favours functions with
%variable parameters, especially in a higher-order context. For example, \lstinline|assoc|
%associates key-value pairs to a target map. It takes one or more key-value pairs and
%applies them left-to-right to the target map. The key problem from a typing perspective
%is \lstinline|assoc|'s arguments are flattened, resulting in \lstinline|assoc| only
%accepting an even number of rest arguments. \lstinline|assoc| is also commonly used as a
%higher-order function.
%\lstinline|assoc| cannot be expressed in Typed Racket. For instance,
%dotted parameters represent an unrestricted number of types, where we require an even number.
%
%The nature of Clojure's idiomatic variable-arity functions suggest we must introduce
%new kinds of dotted parameters. Three main issues must be considered in the context of Typed Clojure.
%Firstly, subtyping between different kinds of dotted and rest
%\footnote{A rest parameter consumes zero or more types, rather than being a sequence of types.}
%parameters can be tricky, only made trickier by adding new kinds of dotted parameters.
%Secondly, elimination rules for dotted parameters in many frequently used Clojure core functions
%difficult to express.
%Thirdly, higher-order functions taking functions with dotted arguments commonly 
%The first issue requires careful design and implementation.
%The second and third points require new constructs, in the form of \emph{projections}
%and abstractions over \emph{dotted} parameters, respectively.



