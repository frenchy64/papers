\documentclass{cshonours}

\usepackage{mmm}
\usepackage{mathpartir}
\usepackage{clj-grammar}
\usepackage[style=numeric]{biblatex}
\addbibresource{bibliography.bib}

\usepackage{listings}
\lstset{ %
  language=Lisp,                % choose the language of the code
  columns=fixed,basewidth=.5em,
  basicstyle=\small\ttfamily,       % the size of the fonts that are used for the code
  %numbers=left,                   % where to put the line-numbers
  %numberstyle=\small\ttfamily,      % the size of the fonts that are used for the line-numbers
  %stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
  %numbersep=5pt,                  % how far the line-numbers are from the code
  %backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  %showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  %showtabs=false,                 % show tabs within strings adding particular underscores
  %frame=single,           % adds a frame around the code
  %tabsize=2,          % sets default tabsize to 2 spaces
  captionpos=t,           % sets the caption-position to bottom
  breaklines=true,        % sets automatic line breaking
  breakatwhitespace=true,    % sets if automatic breaks should only happen at whitespace
  %escapeinside={\%*}{*)},          % if you want to add a comment within your code
}

\title{A Practical Optional Type System for Clojure}
\author{Ambrose Bonnaire-Sergeant}

\keywords{Type systems, Clojure}
% TODO What are categories? cshonours requires them
\categories{}

\begin{document}

\maketitle

\begin{abstract}

Since the first wide-spread programming languages 
like Fortran, LISP, and ALGOL 

there has been a division between languages 
that perform type checking at compile-time and those that don't.  

A recent trend is to combine the advantages of both kinds of languages by adding optional static type systems to languages without static type checking. 
This promises to eliminate many common user errors that are otherwise unnoticed or are caught when the program is run, while conserving the flexibility of the language. 
A major challenge in these combinations is continuing to support the idiomatic style the original language, and some recent attempts appear to have finally produced type systems that have overcome this obstacle.  Most notably, Typed Racket, a typed sister language of the Lisp dialect Racket, is able to statically type check most idiomatic Racket code.

Clojure is a recent increasingly popular Lisp dialect with an emphasis on immutability, and interoperability and execution on popular platforms like the Java Virtual Machine (JVM).
We take the lessons learnt from several projects including Typed Racket and the advanced statically-typed JVM language Scala, and apply them to Clojure in the form of an optional static type system.
In this seminar I will describe my work on building a prototype static type system for Clojure.
This prototype is sufficient to allow experiments with existing Clojure code that is sufficiently complicated
that type checking increases confidence that the code is correct.
My findings show that it appears to be both practical and useful to design and implement an optional static type system for the
Clojure programming language.

\end{abstract}

\tableofcontents

\include{intro}
\include{lit-review}
\include{design-choices}

% A syntactic approach to type soundness (Wright and Felleisen)
% operational semantics
% - See Sam TH's operational semantics
% TAPL 392

% potential proofs/rules
% - hmaps
% - intersection types (protocols + types)
% - subtyping
% - dot methods
% - f-bounded polymorphism

\include{implementation}

% Evaluation
% - successes
% - future work identified

\include{experiments}

\include{future-work}

%
%\begin{mathpar}
%\inferrule*[right=B-Var]
%  {\rho(x) = v}
%  {\rho \vdash x \downarrow v}
%
%\inferrule*[right=B-Assoc]
%  {\rho \vdash e_m \downarrow mi \\
%   \rho \vdash e_k \downarrow k \\
%   \rho \vdash e_v \downarrow v \\
%   \rho \vdash \overrightarrow{e_j}^n \downarrow \overrightarrow{k_j}^n \\
%   \rho \vdash \overrightarrow{e_m}^n \downarrow \overrightarrow{k_m}^n \\
%   \delta(add\_entry, mi, k, v, \overrightarrow{k_j, k_m}^n) = mo}
%  {\rho \vdash (assoc\ e_m\ e_k\ e_v\ \overrightarrow{e_j\ e_m}^n) \downarrow mo}

%\infrule[B-Var]
%  {\rho(x) = v}
%  {\rho \vdash x \downarrow v}
%
%\infrule[B-Assoc]

%\end{mathpar}

\printbibliography[title=References]

\end{document}
