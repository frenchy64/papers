\documentclass{cshonours}

\usepackage{mmm}
\usepackage{mathpartir}
\usepackage{clj-grammar}
\usepackage[style=alphabetic]{biblatex}
\addbibresource{bibliography.bib}

\usepackage{listings}
\lstset{ %
  language=Lisp,                % choose the language of the code
  columns=fixed,basewidth=.5em,
  basicstyle=\small\ttfamily,       % the size of the fonts that are used for the code
  %numbers=left,                   % where to put the line-numbers
  %numberstyle=\small\ttfamily,      % the size of the fonts that are used for the line-numbers
  %stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
  %numbersep=5pt,                  % how far the line-numbers are from the code
  %backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  %showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  %showtabs=false,                 % show tabs within strings adding particular underscores
  %frame=single,           % adds a frame around the code
  %tabsize=2,          % sets default tabsize to 2 spaces
  captionpos=t,           % sets the caption-position to bottom
  breaklines=true,        % sets automatic line breaking
  breakatwhitespace=true,    % sets if automatic breaks should only happen at whitespace
  %escapeinside={\%*}{*)},          % if you want to add a comment within your code
}

\title{A Practical Optional Type System for Clojure}
\author{Ambrose Bonnaire-Sergeant}

\keywords{Type systems, Clojure}
% TODO What are categories? cshonours requires them
\categories{}

\begin{document}

\maketitle

\begin{abstract}

Traditionally there has been a clear distinction between 
programming languages that perform type checking at compile-time, and those that do not.
In particular, the early wide-spread programming languages ALGOL and LISP
could be divided this way: ALGOL performs compile-time (or static) type checking,
and LISP does not.
Static type checking eliminates many common user errors that are otherwise unnoticed or are caught 
when the program is run.
On the other hand, a language without static type checking can often be designed 
to be more flexible and forgiving.

A recent trend is to combine the advantages of both kinds of languages by adding optional static 
type systems to languages without static type checking. 
A major challenge in these combinations is continuing to support the idiomatic style of the original 
language, and some recent attempts appear to have finally produced type systems that have overcome this obstacle.  
Most notably Typed Racket, a typed sister language of the Lisp dialect Racket, is able to statically type 
check most idiomatic Racket code.

Clojure is a recent and increasingly popular programming language that is designed to support 
functional programming and immutability by default. Implementations of Clojure are hosted 
on popular platforms and provide direct interoperability with the host platform.
There are several implementations of Clojure, each targeting different runtimes including
the Java Virtual Machine, the Common Language Runtime, and Javascript virtual machines.

This paper describes my work on designing an optional static type system for Clojure based on
the lessons learnt from several projects, primarily Typed Racket.
A prototype type system is developed for Clojure running on the Java Virtual Machine.
This prototype is sufficient to allow experiments with existing Clojure code that is sufficiently complicated
that type checking increases confidence that the code is correct.
For example, a significant portion of algo.monads, a Clojure Contrib library for monadic programming, 
is able to be type checked. 
On the positive side, most monad, monad transformer, and monadic function definitions can be type checked,
usually by adding type annotations in natural places like function definitions.
Negatively, simple monad comprehensions can be type checked, but require awkward type annotations.

There is significant future work to fully type check all Clojure features and idioms.
For example, multi-method definitions and functions accepting an even number of variable arguments
are troublesome. 
Also, there are desirable features from the Typed Racket project that are missing, such
as automatic runtime contract generation and a sophisticated blame system, 
both which significantly improve error messages when mixing typed and untyped code.
I conclude that it appears to be both practical and useful to design and implement an optional static type system for the
Clojure programming language.

\end{abstract}

\tableofcontents

\include{intro}
\include{lit-review}
\include{design-choices}

% A syntactic approach to type soundness (Wright and Felleisen)
% operational semantics
% - See Sam TH's operational semantics
% TAPL 392

% potential proofs/rules
% - hmaps
% - intersection types (protocols + types)
% - subtyping
% - dot methods
% - f-bounded polymorphism

\include{implementation}

% Evaluation
% - successes
% - future work identified

\include{experiments}

\include{future-work}

%
%\begin{mathpar}
%\inferrule*[right=B-Var]
%  {\rho(x) = v}
%  {\rho \vdash x \downarrow v}
%
%\inferrule*[right=B-Assoc]
%  {\rho \vdash e_m \downarrow mi \\
%   \rho \vdash e_k \downarrow k \\
%   \rho \vdash e_v \downarrow v \\
%   \rho \vdash \overrightarrow{e_j}^n \downarrow \overrightarrow{k_j}^n \\
%   \rho \vdash \overrightarrow{e_m}^n \downarrow \overrightarrow{k_m}^n \\
%   \delta(add\_entry, mi, k, v, \overrightarrow{k_j, k_m}^n) = mo}
%  {\rho \vdash (assoc\ e_m\ e_k\ e_v\ \overrightarrow{e_j\ e_m}^n) \downarrow mo}

%\infrule[B-Var]
%  {\rho(x) = v}
%  {\rho \vdash x \downarrow v}
%
%\infrule[B-Assoc]

%\end{mathpar}

\chapter{Conclusion}

\begin{verbatim}
  Programming is an error-prone task, and verification tools are important.
  Dynamic languages rely on several techniques for verification, but static
  type checking is not often supported.
\end{verbatim}

\printbibliography[title=References]

\end{document}
